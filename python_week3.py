# -*- coding: utf-8 -*-
"""python_week3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fwqXujwsg9g6CSw-hc-D9lArLB977kmY
"""

#Softmax and StableSoftmax
import torch
import torch.nn as nn
class MySoftmax(nn.Module):
    def __init__(self):
        super().__init__()
    def forward(self, x):
        x_exp = torch.exp(x)
        total = x_exp.sum(0, keepdims=True)
        return x_exp / total
class MyStableSoftmax(nn.Module):
    def __init__(self):
        super().__init__()
    def forward(self, x):
        c = torch.max(x, dim = 0)
        x_exp = torch.exp(x-c.values)
        total = x_exp.sum(0, keepdims=True)
        return x_exp / total
data = torch.tensor([1, 2, 3])
softmax = MySoftmax()
stable_softmax = MyStableSoftmax()
output1 = softmax(data)
output2 = stable_softmax(data)
print(output1)
print(output2)

#Ward
from abc import ABC, abstractmethod
class Person(ABC):
    def __init__(self, name, yob):
        self.name = name
        self.yob = yob
    @abstractmethod
    def describe(self):
        pass
    def get_yob(self):
        return self.yob
class Student(Person):
    def __init__(self, name, yob, grade):
        super().__init__(name, yob)
        self.grade = grade
    def describe(self):
        print(f"Student Name: {self.name}, Student Year of Birth: {self.yob}, Student Grade: {self.grade}")
student1 = Student('StudentA', 2010, 7)
student1.describe()
class Teacher(Person):
    def __init__(self, name, yob, subject):
        super().__init__(name, yob)
        self.subject = subject
    def describe(self):
        print(f"Teacher Name: {self.name}, Teacher Year of Birth: {self.yob}, Teacher Subject: {self.subject}")
teacher1 = Teacher('TeacherA', 1969, 'Math')
teacher1.describe()
class Doctor(Person):
    def __init__(self, name, yob, specialist):
        super().__init__(name, yob)
        self.specialist = specialist
    def describe(self):
        print(f"Doctor Name: {self.name}, Doctor Year of Birth: {self.yob}, Doctor Specialist: {self.specialist}")
doctor1 = Doctor('DoctorA', 1945, 'Endocrinologists')
doctor1.describe()
class Ward:
    def __init__(self, name):
        self.__name = name
        self.__list_people = list()
    def add_person(self, person: Person):
        self.__list_people.append(person)
    def describe(self):
        print(f"Name: {self.__name}")
        for person in self.__list_people:
            person.describe()
    def count_doctor(self):
        count = 0
        for person in self.__list_people:
            if isinstance(person, Doctor):
                count += 1
        return count
    def sort_yob(self):
        return self.__list_people.sort(key = lambda x: x.get_yob())
    def compute_average(self):
        sum = 0
        count_teacher = 0
        for person in self.__list_people:
            if isinstance(person, Teacher):
              sum += person.get_yob()
              count_teacher += 1
        return sum / count_teacher
teacher2 = Teacher (name = "teacherB", yob = 1995 , subject = "History")
doctor2 = Doctor (name = "doctorB", yob = 1975 , specialist = "Cardiologists")
ward1 = Ward(name = "ward1")
ward1.add_person(student1)
ward1.add_person(teacher1)
ward1.add_person(teacher2)
ward1.add_person(doctor1)
ward1.add_person(doctor2)
ward1.describe()
print(f'number of doctors: {ward1.count_doctor()}')
ward1.sort_yob()
ward1.describe()
ward1.compute_average()
print(ward1.compute_average())

#Stack
class MyStack:
    def __init__(self, capacity):
        self.capacity = capacity
        self.stack = []
    def is_empty(self):
        return len(self.stack) == 0
    def is_full(self):
        return len(self.stack) == self.capacity
    def push(self, item):
        if self.is_full():
            print("Stack is full")
        else:
            self.stack.append(item)
    def pop(self):
        if self.is_empty():
            print('Stack is empty')
        else:
            return self.stack.pop()
    def top(self):
        if self.is_empty():
            print('Stack is empty')
        else:
            return self.stack[-1]
stack1 = MyStack(capacity =5)
stack1.push(1)
stack1.push(2)
print(stack1.is_full())
print(stack1.top())
print(stack1.pop())
print(stack1.top())
print( stack1.pop())
print(stack1.is_empty())

#Queue
class MyQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = []
    def is_empty(self):
        return len(self.queue) == 0
    def is_full(self):
        return len(self.queue) == self.capacity
    def enqueue(self, item):
        if self.is_full():
            print("Queue is full")
        else:
            self.queue.append(item)
    def dequeue(self):
        if self.is_empty():
            print('Queue is empty')
        else:
            return self.queue.pop(0)
    def front(self):
        if self.is_empty():
            print('Queue is empty')
        else:
            return self.queue[0]
queue1 = MyQueue(capacity=5)
queue1.enqueue(1)
queue1.enqueue(2)
print(queue1.is_full())
print(queue1.front())
print(queue1.dequeue())
print(queue1.front())
print(queue1.dequeue())
print(queue1.is_empty())